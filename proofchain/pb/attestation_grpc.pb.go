// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v4.25.1
// source: attestation.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EventService_StreamEvents_FullMethodName   = "/attestation.EventService/StreamEvents"
	EventService_SubmitEvent_FullMethodName    = "/attestation.EventService/SubmitEvent"
	EventService_SubmitBatch_FullMethodName    = "/attestation.EventService/SubmitBatch"
	EventService_GetEventStatus_FullMethodName = "/attestation.EventService/GetEventStatus"
	EventService_ForceBatch_FullMethodName     = "/attestation.EventService/ForceBatch"
)

// EventServiceClient is the client API for EventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventServiceClient interface {
	// Stream events for batch attestation
	StreamEvents(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[EventRequest, EventResponse], error)
	// Submit a single event
	SubmitEvent(ctx context.Context, in *EventRequest, opts ...grpc.CallOption) (*EventResponse, error)
	// Submit batch of events
	SubmitBatch(ctx context.Context, in *BatchEventRequest, opts ...grpc.CallOption) (*BatchEventResponse, error)
	// Get event status
	GetEventStatus(ctx context.Context, in *EventStatusRequest, opts ...grpc.CallOption) (*EventStatusResponse, error)
	// Force batch settlement
	ForceBatch(ctx context.Context, in *ForceBatchRequest, opts ...grpc.CallOption) (*ForceBatchResponse, error)
}

type eventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEventServiceClient(cc grpc.ClientConnInterface) EventServiceClient {
	return &eventServiceClient{cc}
}

func (c *eventServiceClient) StreamEvents(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[EventRequest, EventResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EventService_ServiceDesc.Streams[0], EventService_StreamEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[EventRequest, EventResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_StreamEventsClient = grpc.BidiStreamingClient[EventRequest, EventResponse]

func (c *eventServiceClient) SubmitEvent(ctx context.Context, in *EventRequest, opts ...grpc.CallOption) (*EventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventResponse)
	err := c.cc.Invoke(ctx, EventService_SubmitEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) SubmitBatch(ctx context.Context, in *BatchEventRequest, opts ...grpc.CallOption) (*BatchEventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchEventResponse)
	err := c.cc.Invoke(ctx, EventService_SubmitBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) GetEventStatus(ctx context.Context, in *EventStatusRequest, opts ...grpc.CallOption) (*EventStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventStatusResponse)
	err := c.cc.Invoke(ctx, EventService_GetEventStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) ForceBatch(ctx context.Context, in *ForceBatchRequest, opts ...grpc.CallOption) (*ForceBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForceBatchResponse)
	err := c.cc.Invoke(ctx, EventService_ForceBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventServiceServer is the server API for EventService service.
// All implementations must embed UnimplementedEventServiceServer
// for forward compatibility.
type EventServiceServer interface {
	// Stream events for batch attestation
	StreamEvents(grpc.BidiStreamingServer[EventRequest, EventResponse]) error
	// Submit a single event
	SubmitEvent(context.Context, *EventRequest) (*EventResponse, error)
	// Submit batch of events
	SubmitBatch(context.Context, *BatchEventRequest) (*BatchEventResponse, error)
	// Get event status
	GetEventStatus(context.Context, *EventStatusRequest) (*EventStatusResponse, error)
	// Force batch settlement
	ForceBatch(context.Context, *ForceBatchRequest) (*ForceBatchResponse, error)
	mustEmbedUnimplementedEventServiceServer()
}

// UnimplementedEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEventServiceServer struct{}

func (UnimplementedEventServiceServer) StreamEvents(grpc.BidiStreamingServer[EventRequest, EventResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamEvents not implemented")
}
func (UnimplementedEventServiceServer) SubmitEvent(context.Context, *EventRequest) (*EventResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitEvent not implemented")
}
func (UnimplementedEventServiceServer) SubmitBatch(context.Context, *BatchEventRequest) (*BatchEventResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitBatch not implemented")
}
func (UnimplementedEventServiceServer) GetEventStatus(context.Context, *EventStatusRequest) (*EventStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEventStatus not implemented")
}
func (UnimplementedEventServiceServer) ForceBatch(context.Context, *ForceBatchRequest) (*ForceBatchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ForceBatch not implemented")
}
func (UnimplementedEventServiceServer) mustEmbedUnimplementedEventServiceServer() {}
func (UnimplementedEventServiceServer) testEmbeddedByValue()                      {}

// UnsafeEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventServiceServer will
// result in compilation errors.
type UnsafeEventServiceServer interface {
	mustEmbedUnimplementedEventServiceServer()
}

func RegisterEventServiceServer(s grpc.ServiceRegistrar, srv EventServiceServer) {
	// If the following call panics, it indicates UnimplementedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EventService_ServiceDesc, srv)
}

func _EventService_StreamEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventServiceServer).StreamEvents(&grpc.GenericServerStream[EventRequest, EventResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_StreamEventsServer = grpc.BidiStreamingServer[EventRequest, EventResponse]

func _EventService_SubmitEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).SubmitEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_SubmitEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).SubmitEvent(ctx, req.(*EventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_SubmitBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).SubmitBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_SubmitBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).SubmitBatch(ctx, req.(*BatchEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_GetEventStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetEventStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetEventStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetEventStatus(ctx, req.(*EventStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_ForceBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).ForceBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_ForceBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).ForceBatch(ctx, req.(*ForceBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventService_ServiceDesc is the grpc.ServiceDesc for EventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "attestation.EventService",
	HandlerType: (*EventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitEvent",
			Handler:    _EventService_SubmitEvent_Handler,
		},
		{
			MethodName: "SubmitBatch",
			Handler:    _EventService_SubmitBatch_Handler,
		},
		{
			MethodName: "GetEventStatus",
			Handler:    _EventService_GetEventStatus_Handler,
		},
		{
			MethodName: "ForceBatch",
			Handler:    _EventService_ForceBatch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamEvents",
			Handler:       _EventService_StreamEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "attestation.proto",
}

const (
	StateChannelService_CreateChannel_FullMethodName    = "/attestation.StateChannelService/CreateChannel"
	StateChannelService_StreamToChannel_FullMethodName  = "/attestation.StateChannelService/StreamToChannel"
	StateChannelService_GetChannelStatus_FullMethodName = "/attestation.StateChannelService/GetChannelStatus"
	StateChannelService_SettleChannel_FullMethodName    = "/attestation.StateChannelService/SettleChannel"
	StateChannelService_CloseChannel_FullMethodName     = "/attestation.StateChannelService/CloseChannel"
)

// StateChannelServiceClient is the client API for StateChannelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StateChannelServiceClient interface {
	// Create a new state channel
	CreateChannel(ctx context.Context, in *CreateChannelRequest, opts ...grpc.CallOption) (*ChannelResponse, error)
	// Stream events to a channel (bidirectional streaming)
	StreamToChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ChannelEventRequest, ChannelEventResponse], error)
	// Get channel status
	GetChannelStatus(ctx context.Context, in *ChannelStatusRequest, opts ...grpc.CallOption) (*ChannelResponse, error)
	// Trigger channel settlement
	SettleChannel(ctx context.Context, in *SettleChannelRequest, opts ...grpc.CallOption) (*SettlementResponse, error)
	// Close a channel
	CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (*ChannelResponse, error)
}

type stateChannelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStateChannelServiceClient(cc grpc.ClientConnInterface) StateChannelServiceClient {
	return &stateChannelServiceClient{cc}
}

func (c *stateChannelServiceClient) CreateChannel(ctx context.Context, in *CreateChannelRequest, opts ...grpc.CallOption) (*ChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChannelResponse)
	err := c.cc.Invoke(ctx, StateChannelService_CreateChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateChannelServiceClient) StreamToChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ChannelEventRequest, ChannelEventResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StateChannelService_ServiceDesc.Streams[0], StateChannelService_StreamToChannel_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChannelEventRequest, ChannelEventResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StateChannelService_StreamToChannelClient = grpc.BidiStreamingClient[ChannelEventRequest, ChannelEventResponse]

func (c *stateChannelServiceClient) GetChannelStatus(ctx context.Context, in *ChannelStatusRequest, opts ...grpc.CallOption) (*ChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChannelResponse)
	err := c.cc.Invoke(ctx, StateChannelService_GetChannelStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateChannelServiceClient) SettleChannel(ctx context.Context, in *SettleChannelRequest, opts ...grpc.CallOption) (*SettlementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SettlementResponse)
	err := c.cc.Invoke(ctx, StateChannelService_SettleChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateChannelServiceClient) CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (*ChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChannelResponse)
	err := c.cc.Invoke(ctx, StateChannelService_CloseChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StateChannelServiceServer is the server API for StateChannelService service.
// All implementations must embed UnimplementedStateChannelServiceServer
// for forward compatibility.
type StateChannelServiceServer interface {
	// Create a new state channel
	CreateChannel(context.Context, *CreateChannelRequest) (*ChannelResponse, error)
	// Stream events to a channel (bidirectional streaming)
	StreamToChannel(grpc.BidiStreamingServer[ChannelEventRequest, ChannelEventResponse]) error
	// Get channel status
	GetChannelStatus(context.Context, *ChannelStatusRequest) (*ChannelResponse, error)
	// Trigger channel settlement
	SettleChannel(context.Context, *SettleChannelRequest) (*SettlementResponse, error)
	// Close a channel
	CloseChannel(context.Context, *CloseChannelRequest) (*ChannelResponse, error)
	mustEmbedUnimplementedStateChannelServiceServer()
}

// UnimplementedStateChannelServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStateChannelServiceServer struct{}

func (UnimplementedStateChannelServiceServer) CreateChannel(context.Context, *CreateChannelRequest) (*ChannelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateChannel not implemented")
}
func (UnimplementedStateChannelServiceServer) StreamToChannel(grpc.BidiStreamingServer[ChannelEventRequest, ChannelEventResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamToChannel not implemented")
}
func (UnimplementedStateChannelServiceServer) GetChannelStatus(context.Context, *ChannelStatusRequest) (*ChannelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetChannelStatus not implemented")
}
func (UnimplementedStateChannelServiceServer) SettleChannel(context.Context, *SettleChannelRequest) (*SettlementResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SettleChannel not implemented")
}
func (UnimplementedStateChannelServiceServer) CloseChannel(context.Context, *CloseChannelRequest) (*ChannelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CloseChannel not implemented")
}
func (UnimplementedStateChannelServiceServer) mustEmbedUnimplementedStateChannelServiceServer() {}
func (UnimplementedStateChannelServiceServer) testEmbeddedByValue()                             {}

// UnsafeStateChannelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StateChannelServiceServer will
// result in compilation errors.
type UnsafeStateChannelServiceServer interface {
	mustEmbedUnimplementedStateChannelServiceServer()
}

func RegisterStateChannelServiceServer(s grpc.ServiceRegistrar, srv StateChannelServiceServer) {
	// If the following call panics, it indicates UnimplementedStateChannelServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StateChannelService_ServiceDesc, srv)
}

func _StateChannelService_CreateChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateChannelServiceServer).CreateChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateChannelService_CreateChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateChannelServiceServer).CreateChannel(ctx, req.(*CreateChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateChannelService_StreamToChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StateChannelServiceServer).StreamToChannel(&grpc.GenericServerStream[ChannelEventRequest, ChannelEventResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StateChannelService_StreamToChannelServer = grpc.BidiStreamingServer[ChannelEventRequest, ChannelEventResponse]

func _StateChannelService_GetChannelStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateChannelServiceServer).GetChannelStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateChannelService_GetChannelStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateChannelServiceServer).GetChannelStatus(ctx, req.(*ChannelStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateChannelService_SettleChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettleChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateChannelServiceServer).SettleChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateChannelService_SettleChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateChannelServiceServer).SettleChannel(ctx, req.(*SettleChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateChannelService_CloseChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateChannelServiceServer).CloseChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StateChannelService_CloseChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateChannelServiceServer).CloseChannel(ctx, req.(*CloseChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StateChannelService_ServiceDesc is the grpc.ServiceDesc for StateChannelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StateChannelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "attestation.StateChannelService",
	HandlerType: (*StateChannelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateChannel",
			Handler:    _StateChannelService_CreateChannel_Handler,
		},
		{
			MethodName: "GetChannelStatus",
			Handler:    _StateChannelService_GetChannelStatus_Handler,
		},
		{
			MethodName: "SettleChannel",
			Handler:    _StateChannelService_SettleChannel_Handler,
		},
		{
			MethodName: "CloseChannel",
			Handler:    _StateChannelService_CloseChannel_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamToChannel",
			Handler:       _StateChannelService_StreamToChannel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "attestation.proto",
}

const (
	DiscoveryService_GetEndpoints_FullMethodName   = "/attestation.DiscoveryService/GetEndpoints"
	DiscoveryService_GetClusterInfo_FullMethodName = "/attestation.DiscoveryService/GetClusterInfo"
)

// DiscoveryServiceClient is the client API for DiscoveryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DiscoveryServiceClient interface {
	// Get list of available ingestion endpoints for load balancing
	GetEndpoints(ctx context.Context, in *EndpointsRequest, opts ...grpc.CallOption) (*EndpointsResponse, error)
	// Get cluster health and capacity info
	GetClusterInfo(ctx context.Context, in *ClusterInfoRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error)
}

type discoveryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDiscoveryServiceClient(cc grpc.ClientConnInterface) DiscoveryServiceClient {
	return &discoveryServiceClient{cc}
}

func (c *discoveryServiceClient) GetEndpoints(ctx context.Context, in *EndpointsRequest, opts ...grpc.CallOption) (*EndpointsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndpointsResponse)
	err := c.cc.Invoke(ctx, DiscoveryService_GetEndpoints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discoveryServiceClient) GetClusterInfo(ctx context.Context, in *ClusterInfoRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterInfoResponse)
	err := c.cc.Invoke(ctx, DiscoveryService_GetClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiscoveryServiceServer is the server API for DiscoveryService service.
// All implementations must embed UnimplementedDiscoveryServiceServer
// for forward compatibility.
type DiscoveryServiceServer interface {
	// Get list of available ingestion endpoints for load balancing
	GetEndpoints(context.Context, *EndpointsRequest) (*EndpointsResponse, error)
	// Get cluster health and capacity info
	GetClusterInfo(context.Context, *ClusterInfoRequest) (*ClusterInfoResponse, error)
	mustEmbedUnimplementedDiscoveryServiceServer()
}

// UnimplementedDiscoveryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDiscoveryServiceServer struct{}

func (UnimplementedDiscoveryServiceServer) GetEndpoints(context.Context, *EndpointsRequest) (*EndpointsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEndpoints not implemented")
}
func (UnimplementedDiscoveryServiceServer) GetClusterInfo(context.Context, *ClusterInfoRequest) (*ClusterInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedDiscoveryServiceServer) mustEmbedUnimplementedDiscoveryServiceServer() {}
func (UnimplementedDiscoveryServiceServer) testEmbeddedByValue()                          {}

// UnsafeDiscoveryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DiscoveryServiceServer will
// result in compilation errors.
type UnsafeDiscoveryServiceServer interface {
	mustEmbedUnimplementedDiscoveryServiceServer()
}

func RegisterDiscoveryServiceServer(s grpc.ServiceRegistrar, srv DiscoveryServiceServer) {
	// If the following call panics, it indicates UnimplementedDiscoveryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DiscoveryService_ServiceDesc, srv)
}

func _DiscoveryService_GetEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscoveryServiceServer).GetEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DiscoveryService_GetEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscoveryServiceServer).GetEndpoints(ctx, req.(*EndpointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiscoveryService_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscoveryServiceServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DiscoveryService_GetClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscoveryServiceServer).GetClusterInfo(ctx, req.(*ClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DiscoveryService_ServiceDesc is the grpc.ServiceDesc for DiscoveryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DiscoveryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "attestation.DiscoveryService",
	HandlerType: (*DiscoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEndpoints",
			Handler:    _DiscoveryService_GetEndpoints_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _DiscoveryService_GetClusterInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "attestation.proto",
}
